<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn Bevy&#x27;s ECS by ripping off someone else&#x27;s project</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B7KRHPXLYN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B7KRHPXLYN');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">06.01: Entities, Components and Systems: Player ECS</li><li class="chapter-item expanded "><a href="06_01/introduction.html"><strong aria-hidden="true">2.</strong> Introduction to step 06.01</a></li><li class="chapter-item expanded "><a href="06_01/base_structure.html"><strong aria-hidden="true">3.</strong> Base structure</a></li><li class="chapter-item expanded "><a href="06_01/world_and_systems.html"><strong aria-hidden="true">4.</strong> World and systems</a></li><li class="chapter-item expanded "><a href="06_01/components_entities_resources.html"><strong aria-hidden="true">5.</strong> Components, entities and resources</a></li><li class="chapter-item expanded "><a href="06_01/keyboard_input.html"><strong aria-hidden="true">6.</strong> Keyboard input</a></li><li class="chapter-item expanded "><a href="06_01/system_sets_introduction.html"><strong aria-hidden="true">7.</strong> Introduction to System sets</a></li><li class="chapter-item expanded "><a href="06_01/query_basics.html"><strong aria-hidden="true">8.</strong> Query basics</a></li><li class="chapter-item expanded affix "><li class="part-title">06.02: Entities, Components and Systems: Dungeon ECS</li><li class="chapter-item expanded "><a href="06_02/introduction.html"><strong aria-hidden="true">9.</strong> Introduction to step 06.02</a></li><li class="chapter-item expanded "><a href="06_02/querying_entities_and_param_sets.html"><strong aria-hidden="true">10.</strong> Querying: Entities and Param sets</a></li><li class="chapter-item expanded affix "><li class="part-title">07.01-02: Turn-based Games: Wandering/Turn-based</li><li class="chapter-item expanded "><a href="07_01-02/introduction.html"><strong aria-hidden="true">11.</strong> Introduction to steps 07.01-02</a></li><li class="chapter-item expanded "><a href="07_01-02/a_look_at_the_states_model_in_the_source_project.html"><strong aria-hidden="true">12.</strong> A look at the states model in the source project</a></li><li class="chapter-item expanded "><a href="07_01-02/a_basic_states_model_in_bevy.html"><strong aria-hidden="true">13.</strong> A basic states model in Bevy</a></li><li class="chapter-item expanded "><a href="07_01-02/designing_the_states.html"><strong aria-hidden="true">14.</strong> Designing the states</a></li><li class="chapter-item expanded "><a href="07_01-02/implementing_the_states_in_bevy.html"><strong aria-hidden="true">15.</strong> Implementing the states in Bevy</a></li><li class="chapter-item expanded affix "><li class="part-title">07.03: Turn-based Games: Intent</li><li class="chapter-item expanded "><a href="07_03/introduction.html"><strong aria-hidden="true">16.</strong> Introduction to step 07.03</a></li><li class="chapter-item expanded "><a href="07_03/managed_event_passing.html"><strong aria-hidden="true">17.</strong> Managed event passing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Bevy&#x27;s ECS by ripping off someone else&#x27;s project</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This guide introduces developers to Bevy's ECS component, by porting the game written for <a href="https://pragprog.com/titles/hwrust/hands-on-rust">Hands-on Rust: Effective Learning through 2D Game Development and Play</a> to Bevy's ECS.</p>
<h2 id="how-to-approach-this-book"><a class="header" href="#how-to-approach-this-book">How to approach this book</a></h2>
<p>The book, and the <a href="https://github.com/thebracket/HandsOnRust">source project</a>, are structured as a series of incremental steps, leading to a full game.</p>
<p>In the <a href="https://github.com/64kramsystem/rust-game-ports">Rust ports repository</a>, I've made minor cleanups and restructurings to the source project; the locations of the projects are:</p>
<ul>
<li><a href="https://github.com/64kramsystem/rust-game-ports/tree/master/rusty_roguelike-bevy">port project</a></li>
<li><a href="https://github.com/64kramsystem/rust-game-ports/tree/master/source_projects/rusty_roguelike">source project</a></li>
</ul>
<p>The steps have been numbered (and have matching names in the source/port), in order to facilitate sequential examination and comparison; each step is an independent workspace.</p>
<p>This book presents multiple chapters for each step, explaining the concepts involved. When reading a chapter, one can compare the source step (workspace) with the ported one, and/or with the previous step in the respective project.</p>
<p>The starting chapter is 06.01, where an ECS is introduced in the design. Steps that don't introduce any new ECS concept, or don't significantly extend an introduced one, are skipped.</p>
<p>It's technically possible to read this book standalone, without the source one, but for newcomers to ECS, it's not advised, as in this context I'm not explaining the ECS concepts (only their Bevy API implementation).</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>The Bevy used version is 0.7.0; all the API links refer to the tag <code>v0.7.0</code> in <a href="https://github.com/bevyengine/bevy">Bevy's repository</a>.</p>
<h2 id="port-style"><a class="header" href="#port-style">Port style</a></h2>
<p>Since comparison is a foundation of this book, I've maintained high and low-level structures as similar as I could; the most radical divergence is due to Bevy's state management. There are still a few differences, but they're minor.</p>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>This project has been kindly sponsored by <a href="https://www.ticketsolve.com">Ticketsolve</a>; naturally, it wouldn't have been possible without the great work of <a href="https://twitter.com/herberticus">Herbert Wolverson</a>, and the <a href="https://bevyengine.org">Bevy</a> community.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-step-0601"><a class="header" href="#introduction-to-step-0601">Introduction to step 06.01</a></h1>
<p>In this chapter, the basic elements of the ECS system are introduced.</p>
<p>The directory name is <code>06_EntitiesComponentsAndSystems_01_playerecs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-structure"><a class="header" href="#base-structure">Base structure</a></h1>
<p>The very first step in the port is plugging Bevy's ECS. The source project has a mixed, game engine-wise, design:</p>
<ul>
<li>the game loop is managed by the game engine (<a href="https://github.com/amethyst/bracket-lib">bracket-lib</a>);</li>
<li>for each cycle (frame), an update is invoked on the ECS (<a href="https://github.com/amethyst/legion">Legion</a>).</li>
</ul>
<p>This is bare-bones structure of the source project:</p>
<pre><code class="language-rs">// source: main.rs

struct State {
    ecs: World,
    resources: Resources,
    systems: Schedule,
}

impl State {
    fn new() -&gt; Self {
        // [...]
        Self {
            ecs: World::default(),
            resources: Resources::default(),
            systems: build_scheduler(),
        }
    }
}

impl GameState for State {
    fn tick(&amp;mut self, ctx: &amp;mut BTerm) {
        // [...]
        self.systems.execute(&amp;mut self.ecs, &amp;mut self.resources);
        render_draw_buffer(ctx).expect(&quot;Render error&quot;);
    }
}

fn main() -&gt; BError {
    // [...]
    main_loop(context, State::new())
}
</code></pre>
<p>The translation is straightforward:</p>
<ul>
<li><code>World</code> and <code>Resources</code> map to <a href="https://github.com/bevyengine/bevy/blob/83c6ffb73c4a91182cda10141f824987ef3fba2f/crates/bevy_app/src/app.rs#L46"><code>App</code></a> (which also owns the resources)</li>
<li>Legion's systems update for each tick maps to the <a href="https://github.com/bevyengine/bevy/blob/83c6ffb73c4a91182cda10141f824987ef3fba2f/crates/bevy_app/src/app.rs#L111"><code>App#update()</code> API</a>.</li>
</ul>
<p>leading to:</p>
<pre><code class="language-rs">// port: main.rs

struct State {
    ecs: App,
}

impl State {
    fn new() -&gt; Self {
        // [...]
        Self { ecs: App::new() }
    }
}

impl GameState for State {
    fn tick(&amp;mut self, ctx: &amp;mut BTerm) {
        // [...]
        self.ecs.update();
        render_draw_buffer(ctx).expect(&quot;Render error&quot;);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world-and-systems"><a class="header" href="#world-and-systems">World and systems</a></h1>
<h2 id="world"><a class="header" href="#world">World</a></h2>
<p>In Legion, we work directly on <code>World</code> and <code>Resources</code>:</p>
<pre><code class="language-rs">// source: main.rs

let mut ecs = World::default();
let mut resources = Resources::default();

// [...]

self.systems.execute(&amp;mut self.ecs, &amp;mut self.resources);
</code></pre>
<p>In Bevy, the semantics are similar, although the idea is to use systems without interacting with the underlying data structures; this is because the engine manages them, and accessing them directly limits the (parallel) scheduling.</p>
<p>We still can manipulate <code>World</code>, just as long as we're aware that accessing it mutably, prevents systems from running. In the ported project, in order to maintain the structure similar to the source, I've intentionally done it:</p>
<pre><code class="language-rs">// port: spawner.rs

// The world instance is accessible via App#world.
//
world.spawn().insert_bundle((
    Player,
    PointC(pos),
    Render {
        color: ColorPair::new(WHITE, BLACK),
        glyph: to_cp437('@'),
    },
));
</code></pre>
<p>Generally speaking, while one can use this approach, in particular in stages where performance is not a concern, using systems should be preferred.</p>
<h2 id="systems"><a class="header" href="#systems">Systems</a></h2>
<p>In Legion, systems require attributes, and queries are manually invoked:</p>
<pre><code class="language-rs">// source: entity_render.rs

#[system]
#[read_component(Point)]
#[read_component(Render)]
pub fn entity_render(ecs: &amp;SubWorld, #[resource] camera: &amp;Camera) {
    // ...

    &lt;(&amp;Point, &amp;Render)&gt;::query()
        .iter(ecs)
        .for_each(|(pos, render)| {
            draw_batch.set(*pos - offset, render.color, render.glyph);
        });

    // ...
}
</code></pre>
<p>In Bevy, systems are simpler; they don't require attributes, and the queries are declared as function parameters:</p>
<pre><code class="language-rs">// port: entity_render.rs

pub fn entity_render(query: Query&lt;(&amp;PointC, &amp;Render)&gt;, camera: Res&lt;Camera&gt;) {
    // ...

    for (pos, render) in query.iter() {
        draw_batch.set(pos.0 - offset, render.color, render.glyph);
    }

    // ...
}
</code></pre>
<p>In this example, we perform two accesses:</p>
<ul>
<li>we query entities, via <code>Query</code> type; in this case, entities with <code>PointC</code> and <code>Render</code> components</li>
<li>we retrieve a <code>Camera</code> resource, via <code>Res</code> (readonly access) type</li>
</ul>
<p>Another fundamental API component is <code>Commands</code>, which is used primarly to add/remove entities and resources.</p>
<p>The following example shows other functionalities:</p>
<pre><code class="language-rs">// port: player_input.rs

pub fn player_input(
    mut commands: Commands,
    mut player_query: Query&lt;&amp;mut PointC, With&lt;Player&gt;&gt;,
    (map, key, mut camera): (Res&lt;Map&gt;, Option&lt;Res&lt;VirtualKeyCode&gt;&gt;, ResMut&lt;Camera&gt;),
) {
  // ...
}
</code></pre>
<p>There are a few new concepts here (besides <code>Commands</code>):</p>
<ol>
<li><code>With</code>: query entities with a certain component, without retrieving it</li>
<li><code>ResMut</code>: mutably access a resource</li>
<li><code>Option&lt;Res&gt;</code>: access a resource that may not be existing</li>
</ol>
<p>Note how <code>Option&lt;Res&lt;T&gt;&gt;</code> is semantically different from <code>Res&lt;Option&lt;T&gt;&gt;</code>:</p>
<ol>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code> is a resource of type <code>T</code> that may not be stored</li>
<li><code>Res&lt;Option&lt;T&gt;&gt;</code> is a resource of type <code>&lt;Option&lt;T&gt;&gt;</code> that is assumed to be stored</li>
</ol>
<p>if a resource is not stored, the system will panic in the second case, but not the first.</p>
<p>Querying will be explored more in detail in the next chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-entities-and-resources"><a class="header" href="#components-entities-and-resources">Components, entities and Resources</a></h1>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>In Bevy, components must derive <code>Component</code>:</p>
<pre><code class="language-rs">// port: component.rs

#[derive(Component)]
pub struct Render {
    pub color: ColorPair,
    pub glyph: FontCharType,
}

#[derive(Component)]
pub struct Player;

#[derive(Component)]
pub struct PointC(pub Point);
</code></pre>
<p>There's something interesting here: <code>PointC</code>, which is a tuple struct, unlike the other (regular) structs.</p>
<p>Why so? Because the type <code>Point</code> is not defined in our crate, and therefore, can't derive <code>Component</code>; in order to work this problem around, we wrap it in our type (<code>PointC</code>), and derive the wrapping type.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>Adding entities to the ECS is trivial both in Legion and Bevy.</p>
<p>The simplest possible form that we can adopt to create an entity (in Bevy lexicon, a &quot;Bundle&quot;), is to insert a tuple:</p>
<pre><code class="language-rs">// port: spawner.rs

// Note that we generally use systems to manage entities, but in this case, we're strictly following
// the source project's design.
//
pub fn spawn_player(world: &amp;mut World, pos: Point) {
    world.spawn().insert_bundle((
        Player,
        PointC(pos),
        Render {
            color: ColorPair::new(WHITE, BLACK),
            glyph: to_cp437('@'),
        },
    ));
}
</code></pre>
<p>The entity inserted above has three components (<code>Player</code>, <code>PointC</code> and <code>Render</code>), which are bundled together as tuple.</p>
<p>We can use a more declarative approach, and use an annotated struct:</p>
<pre><code class="language-rs">#[derive(Bundle)]
struct PlayerBundle {
  player: Player,
  pos: PointC,
  render: Render,
}
</code></pre>
<p>It's crucial, in this case, to annotate the struct with <code>#[derive(Bundle)]</code>; if one forgets this, and accidentally uses a bundle as component, no error will be raised!</p>
<p>Bundles can be nested (and again, we need to annotate the children, this time with <code>#[bundle]</code>), although in this project, this feature is not used:</p>
<pre><code class="language-rs">#[derive(Bundle)]
struct PlayerBundle {
  player: Player,
  pos: PointC,

  #[bundle]
  sprite: SpriteSheetBundle,
}
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>Resources, differently from components, currently (this may change in the future!) don't need to be derived; anything inserted in Bevy's ECS is a resource.</p>
<pre><code class="language-rs">// port: main.rs

// key is a bracket-lib `VirtualKeyCode` type
// ecs is the Bevy `App` instance
//
if let Some(key) = ctx.key {
    self.ecs.insert_resource(key);
} else {
    self.ecs.world.remove_resource::&lt;VirtualKeyCode&gt;();
}
</code></pre>
<p>Since there can be only one resource for a given type, when a resource is inserted, any existing resource with the same type is going to be overwritten.</p>
<p>Note how in the example above, we remove a resource through <code>World</code>; while this is acceptable, we should strive to use systems where possible. The technical reason for this usage is that Bevy provides resource insertion via the <code>App</code> instance, but not the removal. This makes sense architecturally, since in the initialization of a project, one insert resources rather than removing them.</p>
<p>Later, we'll see how to access resources in systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard input</a></h1>
<p>In Bevy, keyboard input handling is performed via resources:</p>
<pre><code class="language-rs">fn keyboard_input(keys: Res&lt;Input&lt;KeyCode&gt;&gt;) {
    if keys.just_pressed(KeyCode::W) { /* ... */ }

    // ...
}
</code></pre>
<p>In this context, we rely on bracket-lib for input handling, so the API above is not used.</p>
<p>The only thing that needs to be kept in mind is that, in the context of the port, we need to remove the key resource:</p>
<pre><code class="language-rs">// port: main.rs

// key is a bracket-lib `VirtualKeyCode` type
//
if let Some(key) = ctx.key {
    self.ecs.insert_resource(key);
} else {
    self.ecs.world.remove_resource::&lt;VirtualKeyCode&gt;();
}
</code></pre>
<p>If we forget the <code>remove_resource</code> invocation, if the player doesn't press any key, the current frame will still hold the keypress resource from the previous frame!</p>
<p>This is not needed when using Bevy input handling (with an exception: see <a href="https://bevy-cheatbook.github.io/programming/states.html#with-input">here</a>); it's only necessary in the context of the port.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-system-sets"><a class="header" href="#introduction-to-system-sets">Introduction to System sets</a></h1>
<p>One fundamental different between the architectures of the source design (Legion) and the port (Bevy) is how systems are grouped and scheduled.</p>
<p>In Legion, this is very simple; all the systems that belong to a (conceptual) state, are grouped together into a a &quot;Schedule&quot;, which is sent to Legion, to be run on each update:</p>
<pre><code class="language-rs">// source: mod.rs

Schedule::builder()
    .add_system(player_input::player_input_system())
    .add_system(map_render::map_render_system())
    .add_system(entity_render::entity_render_system())
    .build()

// source: main.rs

// `self.systems` is the Schedule instance built above.
//
self.systems.execute(&amp;mut self.ecs, &amp;mut self.resources);
</code></pre>
<p>Bevy uses similar semantics as well, however, they are more conceptually more complex; the closest concept in Bevy is the system of <code>Stage</code>s and <code>SystemSet</code>s. In this chapter, we'll explore the <code>SystemSet</code>s.</p>
<h2 id="warning"><a class="header" href="#warning">Warning</a></h2>
<p>As of v0.7, Bevy's states are practically unusable, except for trivial programs; this is due to the internal APIs used to implement them (see <a href="https://bevy-cheatbook.github.io/programming/states.html#combining-with-other-run-criteria">here</a>). Trying, for example, to use the standard <code>SystemSet</code>/<code>Stage</code> Bevy APIs for this project, will cause the program to hang.</p>
<p>Fortunately, there is a third party crate, <a href="https://github.com/IyesGames/iyes_loopless">iyes_loopless</a>, that solves this problem, while also maintaining the semantics identical (or very close) to Bevy's, with a clean interface.</p>
<p>The rest of this book assumes that the <code>iyes_loopless</code> crate is used:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
bevy = &quot;0.7.0&quot;
iyes_loopless = &quot;0.5.1&quot;
</code></pre>
<h2 id="systemsets"><a class="header" href="#systemsets"><code>SystemSet</code>s</a></h2>
<p>A <code>SystemSet</code> in Bevy, is the abstraction that allows grouping and scheduling the systems, based on user-provided properties.</p>
<p>At this step, only the grouping functionality is used:</p>
<pre><code class="language-rs">// port: mod.rs

pub fn build_system_set() -&gt; SystemSet {
    SystemSet::new()
        .with_system(player_input::player_input)
        .with_system(map_render::map_render)
        .with_system(entity_render::entity_render)
}
</code></pre>
<p>The above is the simplest form that a system set can have: an anonymous group of systems that will run in parallel.</p>
<p>Don't forget the <em>parallel</em> - by default, Bevy runs the systems in parallel, so consider this when designing the system.</p>
<p>Another extremely important concept is that changes applied by a system to entities, are <strong>not</strong> seen by systems in the same system set. This doesn't matter now (the renderings are independent of the player entity properties), so we'll get back on this later.</p>
<p>In the most basic form, system sets are registered with Bevy directly on the <code>App</code> instance:</p>
<pre><code class="language-rs">// port: main.rs

ecs.add_system_set(build_system_set());
</code></pre>
<p>Bevy provides APIs to organize system sets when more are added; at this stage, since there's only one, we register it directly without setting any property.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-basics"><a class="header" href="#query-basics">Query basics</a></h1>
<p>Queries are a shiny example of Bevy's capabilities. Putting aside performance, any project will certainly benefit from their ergonomy.</p>
<p>Their distinctive trait is that they're entirely, and automatically, defined by the systems function signature, while allowing at the same time a great amount of flxeibility.</p>
<h2 id="basic-queries-definition-and-iteration"><a class="header" href="#basic-queries-definition-and-iteration">Basic queries definition and iteration</a></h2>
<p>This is a basic (edited) example:</p>
<pre><code class="language-rs">// port: entity_render.rs

pub fn entity_render(query: Query&lt;(&amp;PointC, Option&lt;&amp;Render&gt;)&gt;) {
    for (pos: &amp;PointC, render: Option&lt;&amp;Render&gt;) in query.iter() {
        if let Some(render) = render {
          // ...
        }
    }
}
</code></pre>
<p>Here, we query all the entities that have a <code>PointC</code>, and optionally a <code>Render</code> component, and retrieve both of them in the query.</p>
<p>Iteration can be mutable or immutable; in order to make the above mutable:</p>
<ul>
<li>make <code>query</code> mutable: <code>mut Query&lt;(&amp;PointC, Option&lt;&amp;Render&gt;)&gt;</code></li>
<li>use the mutable iterator API: <code>query.iter_mut()</code></li>
</ul>
<h2 id="resources-and-commands"><a class="header" href="#resources-and-commands">Resources and commands</a></h2>
<p>In addition to Queries, systems are also typically provided access to commands and resources:</p>
<pre><code class="language-rs">// port: player_input.rs

pub fn player_input(
    mut commands: Commands,
    mut player_query: Query&lt;&amp;mut PointC, With&lt;Player&gt;&gt;, //(1) (2)
    (map, key, mut camera): (Res&lt;Map&gt;, Option&lt;Res&lt;VirtualKeyCode&gt;&gt;, ResMut&lt;Camera&gt;),
)
</code></pre>
<p>Commands are used to perform write operations, typically on entities and resources; while the details will be described later, in this context, an example invocation is:</p>
<pre><code class="language-rs">// port: player_input.rs

commands.remove_resource::&lt;VirtualKeyCode&gt;();
</code></pre>
<p>which removes a resource from the storage.</p>
<p>We can observe resources access on the third set of parameters; its definition is intuitive, and the main information we need to know is:</p>
<ul>
<li>if a resource may not exist, it must be accessed via <code>Option&lt;Res&lt;T&gt;&gt;</code>;</li>
<li>immutable/mutable access to a resource are performed via, respectively, the types <code>Res</code>/<code>ResMut</code>.</li>
</ul>
<p>Queries resources implement <code>Deref</code>/<code>DerefMut</code>, so we can access them without any syntactic requirement, for example:</p>
<pre><code class="language-rs">// port: player_input.rs

camera.on_player_move(destination);
</code></pre>
<p>which is invoking the method:</p>
<pre><code class="language-rs">// port: camera.rs

impl Camera {
    pub fn on_player_move(&amp;mut self, player_position: Point) { /* ... */ }
}
</code></pre>
<p>since access to <code>ResMut</code> automatically dereferences to <code>&amp;mut Camera</code>.</p>
<h2 id="query-conditionals"><a class="header" href="#query-conditionals">Query conditionals</a></h2>
<p>By using components directly as query parameters, we've made an implicit assumption: that we want to search entities that include all the components specified, and that we want to retrieve all the components.</p>
<p>A companion concept one may want to express is exclusion: query entities that do <em>not</em> include a component; we use the <code>With</code> trait for this:</p>
<pre><code class="language-rs">// port: entity_render.rs

pub fn entity_render(query: Query&lt;&amp;PointC, Without&lt;Invisibility&gt;&gt;) {
    for pos: &amp;PointC in query.iter() {
      // ...
    }
}
</code></pre>
<p>in this case we want all the entities that have a <code>PointC</code> component, but not an <code>Invisibility</code> one.</p>
<p>There's also something worth mentioning: when querying a single component, we don't use a tuple as <code>Query</code> type parameter <code>Query&lt;(&amp;Player), ...&gt;</code>, but the type alone; this has an effect on the iteration, which is <code>pos: &amp;PointC</code> instead of <code>(pos: &amp;PointC)</code>.</p>
<p>The port does not make use of the <code>Without</code> conditionals, however, there is a link: the inclusion conditional - <code>With</code>.</p>
<p>What's the use, if <code>Query</code> implicitly perform inclusion? Convenience, and potentially performance. In some cases, we query for a component, but we don't need to actively use it; by specifying it as <code>With</code> parameter, it's not retrieved; an (edited) example is:</p>
<pre><code class="language-rs">// port: player_input.rs

pub fn player_input(mut player_query: Query&lt;&amp;mut PointC, With&lt;Player&gt;&gt;) {
    if let Ok(pos) = player_query.get_single() {
        camera.on_player_move(pos);
    }
}
</code></pre>
<p>In this case we want to know the position of the player, in order to process it, but since we don't process the Player component, we don't retrieve it.</p>
<p>There's a new API used here: <code>get_single()</code>; it is part of a family of APIs that allow access to a set of components in a query, without iteration:</p>
<table><thead><tr><th>API</th><th align="center">Checked? (Ret. type)</th><th align="center">Access</th></tr></thead><tbody>
<tr><td><code>single()</code></td><td align="center">N (<code>T</code>)</td><td align="center">immutable</td></tr>
<tr><td><code>single_mut()</code></td><td align="center">N (<code>T</code>)</td><td align="center">mutable</td></tr>
<tr><td><code>get_single()</code></td><td align="center">Y (<code>Result&lt;T&gt;</code>)</td><td align="center">immutable</td></tr>
<tr><td><code>get_single_mut()</code></td><td align="center">Y (<code>Result&lt;T&gt;</code>)</td><td align="center">mutable</td></tr>
</tbody></table>
<p>(note that the return type is simplified)</p>
<p>The APIs are easy to remember:</p>
<ul>
<li>the <code>get_</code> prefix specifies checked access (returns <code>None</code> if an instance is not found, instead of panicking), similarly to <code>HashMap</code>;</li>
<li>the <code>_mut</code> suffix specifies mutable access.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-step-0602"><a class="header" href="#introduction-to-step-0602">Introduction to step 06.02</a></h1>
<p>In this chapter, we're going to explore some other <code>Query</code>ing concepts.</p>
<p>The directory name is <code>06_EntitiesComponentsAndSystems_02_dungeonecs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querying-entities-and-param-sets"><a class="header" href="#querying-entities-and-param-sets">Querying: Entities and Param sets</a></h1>
<h2 id="querying-entities"><a class="header" href="#querying-entities">Querying entities</a></h2>
<p>In the previous chapter about queries, we've queried, and acted upon, only components. How about we need to act entities?</p>
<p>Both Legion and Bevy use a very similar interface - simply, by adding <code>Entity</code> to the query interface.</p>
<p>This is a query example:</p>
<pre><code class="language-rs">// port: collisions.rs (edited)

pub fn collisions(
    mut commands: Commands,
    enemies_query: Query&lt;(Entity, &amp;PointC), With&lt;Enemy&gt;&gt;,
) {
    for (entity, pos) in enemies_query.iter() {
        // ... act on the entity ...
    }
}
</code></pre>
<p>The type <code>Entity</code> is a classic example of handle; it's a lightweight type that supports common operations (copy, comparison, hash...), and therefore, can be conveniently passed around.</p>
<p>Expanding the example above, we can observe how we actually use it:</p>
<pre><code class="language-rs">// port: collisions.rs

pub fn collisions(
    mut commands: Commands,
    player_query: Query&lt;&amp;PointC, With&lt;Player&gt;&gt;,
    enemies_query: Query&lt;(Entity, &amp;PointC), With&lt;Enemy&gt;&gt;,
) {
    let player_pos = player_query.single().0;

    for (entity, pos) in enemies_query.iter() {
        if pos.0 == player_pos {
            commands.entity(entity).despawn()
        }
    }
}
</code></pre>
<p>specifically, we pass it to the entity despawning API, when certain component conditions are met (enemy <code>pos</code> matching the player <code>pos</code>).</p>
<p>Watch out! As we'll see later, despawning doesn't have an immediate effect.</p>
<h2 id="param-sets"><a class="header" href="#param-sets">Param sets</a></h2>
<p>Param sets are a functionality that is not needed in the port, but it's important to know nonetheless.</p>
<p>Let's say, for the sake of example, that we have the following system:</p>
<pre><code class="language-rs">// port: collisions.rs (edited)

pub fn collisions(
    player_query: Query&lt;&amp;PointC, With&lt;Player&gt;&gt;,
    mut enemies_query: Query&lt;&amp;mut PointC, With&lt;Enemy&gt;&gt;,
) {
    let player_pos = player_query.single().0;

    for mut pos in enemies_query.iter_mut() {
        if pos.0 == player_pos {
            pos.0.x = 0;
            pos.0.y = 0;
        }
    }
}
</code></pre>
<p>which model a logic where instead of despawning the enemy entities, we move them away (by changing pos).</p>
<p>The project compiles! But, surprise surprise... once when running, we get a crash:</p>
<pre><code>thread 'main' panicked at 'error[B0001]: Query&lt;(Entity, &amp;mut PointC), With&lt;Enemy&gt;&gt;
in system collisions accesses component(s) PointC in a way that conflicts with a
previous system parameter. Consider using `Without&lt;T&gt;` to create disjoint Queries
or merging conflicting Queries into a `ParamSet`.', /home/user/.cargo/registry/src/github.com-1ecc6299db9ec823/bevy_ecs-0.7.0/src/system/system_param.rs:173:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4cbaac699c14b7ac7cc80e54823b2ef6afeb64af/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/4cbaac699c14b7ac7cc80e54823b2ef6afeb64af/library/core/src/panicking.rs:142:14
   2: bevy_ecs::system::system_param::assert_component_access_compatibility
             at /home/user/.cargo/registry/src/github.com-1ecc6299db9ec823/bevy_ecs-0.7.0/src/system/system_param.rs:173:5
   3: &lt;bevy_ecs::query::state::QueryState&lt;Q,F&gt; as bevy_ecs::system::system_param::SystemParamState&gt;::init
             at /home/user/.cargo/registry/src/github.com-1ecc6299db9ec823/bevy_ecs-0.7.0/src/system/system_param.rs:113:9
   4: &lt;(P0,P1,P2) as bevy_ecs::system::system_param::SystemParamState&gt;::init
             at /home/user/.cargo/registry/src/github.com-1ecc6299db9ec823/bevy_ecs-0.7.0/src/system/system_param.rs:1247:21
</code></pre>
<p>This is interesting; we're prevented from query <code>PointC</code> in two queries, with incompatible access mode. Bevy doesn't enforce incompatible access compile-time, but it does enforce it runtime.</p>
<p>In order to solve this problem, one of the two solutions referenced is to use <code>ParamSet</code>:</p>
<pre><code class="language-rs">pub fn collisions(
    mut queries: ParamSet&lt;(
        Query&lt;&amp;PointC, With&lt;Player&gt;&gt;,
        Query&lt;&amp;mut PointC, With&lt;Enemy&gt;&gt;,
    )&gt;,
) {
    let player_pos = queries.p0().single().0;

    for mut pos in queries.p1().iter_mut() {
        if pos.0 == player_pos {
            pos.0.x = 0;
            pos.0.y = 0;
        }
    }
}
</code></pre>
<p>There's no significant difference; we just group the queries inside a <code>ParamSet</code>, and access them via <code>pN()</code> functions. Considering the constraint, this is impressively ergonomic!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-steps-0701-02"><a class="header" href="#introduction-to-steps-0701-02">Introduction to steps 07.01-02</a></h1>
<p>This chapter covers both steps 07.01 and 07.02; we're going to explore <code>State</code>s, <code>SystemSet</code>s and <code>Stage</code>s (and the <code>iyes_loopless</code> crate).</p>
<p>The Bevy concepts described here are the foundation for structuring games, and this step is the one that departs the most from the source project.</p>
<p>The directory names are <code>07_TurnBasedGames_01_wandering</code> and <code>07_TurnBasedGames_02_turnbased</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-look-at-the-states-model-in-the-source-project"><a class="header" href="#a-look-at-the-states-model-in-the-source-project">A look at the states model in the source project</a></h1>
<h2 id="source-structure-and-bevys-stages"><a class="header" href="#source-structure-and-bevys-stages">Source structure, and Bevy's <code>Stage</code>s</a></h2>
<p>Before getting technical, we need to have a look at how the source project models the states:</p>
<pre><code class="language-rs">// source: mod.rs (edited)

pub fn build_input_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(player_input::player_input_system())
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
}

pub fn build_player_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(collisions::collisions_system())
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
        .add_system(end_turn::end_turn_system())
}

pub fn build_monster_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(random_move::random_move_system())
        .add_system(collisions::collisions_system())
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
        .add_system(end_turn::end_turn_system())
}
</code></pre>
<p>We observe that there are three states:</p>
<ol>
<li>player input</li>
<li>collision handling (following player move)</li>
<li>monster moving, and collision handling</li>
</ol>
<p>Every state performs rendering; state change is performed in two different ways:</p>
<ul>
<li>on the player input state, performed by the <code>player_input</code> system, when the user presses a key;</li>
<li>on the other states, performed by an adhoc system.</li>
</ul>
<p>As previously mentioned, Bevy does have a concept semantically similar to Legion's <code>Schedule</code>, however, it's more complicated, and it's better/closer modeled by a set of other types.</p>
<h2 id="commands-flushing-and-stages-modeling"><a class="header" href="#commands-flushing-and-stages-modeling">Commands flushing and <code>Stage</code>s modeling</a></h2>
<p>In the source schedulers, there's something interesting - the <code>flush()</code> commands:</p>
<pre><code class="language-rs">// source: mod.rs

pub fn build_monster_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(random_move::random_move_system())
        .flush()
        .add_system(collisions::collisions_system())
        .flush()
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
        .add_system(end_turn::end_turn_system())
        .build()
}
</code></pre>
<p>This is a crucial concept to understand!</p>
<p>When ECSs like Legion or Bevy modify entities/components, they don't commit the changes immediately; if one accidentally forgets flushing, it will lead to a very confusing situation, because systems won't find the expected data.</p>
<p>Compared to (current) Bevy, Legion has an advantage - as seen above, Legion has an API for flushing at will, while Bevy doesn't (as of Jun/2022, there's an open issue).</p>
<p>Fortunately, we can easily model this behavior using <code>Stage</code>s - when a <code>Stage</code> is completed, the changes are committed.</p>
<p>Bevy's model has a disadvantage, though: we'll need to model more states than we do in Legion. In the source project, there are three schedulers, and that's all; in Bevy, we'll need:</p>
<ul>
<li>three states, one for each Legion scheduler</li>
<li>seven stages, one for each commands transaction</li>
</ul>
<p>This is not dramatic, but there is certainly an increase of the complexity that we'll need to handle; fortunately, in our case, we can reduce the number of stages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-states-model-in-bevy"><a class="header" href="#a-basic-states-model-in-bevy">A basic states model in Bevy</a></h1>
<h2 id="states-modeling-problems-in-bevy-v07"><a class="header" href="#states-modeling-problems-in-bevy-v07">States modeling problems in Bevy v0.7</a></h2>
<p>Prior to any discussion, it must be pointed out that Bevy's state modeling <em>as a whole</em>, as of v0.7, it's broken: using the related APIs to their full extent in a project, will cause breakages (e.g. Bevy will hang); a typical example is that one can't use <code>FixedTimeStep</code>s and <code>State</code>s at the same time, or, in the case of this project, <code>State</code>s with <code>Stage</code>s.</p>
<p>Fortunately, a 3rd party developer has created a plugin that solves this problem: <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>. In order to proceed with the next steps, it's therefore necessary to add it to the Cargo configuration.</p>
<p>As of June 2022, it's planned for future Bevy versions to integrate the <code>iyes_loopless</code> logic in Bevy.</p>
<h2 id="first-concept-stages"><a class="header" href="#first-concept-stages">First concept: <code>Stage</code>s</a></h2>
<p>In the previous chapter, we've seen the source project's states model. In order to translate it in Bevy, we'll use three major concepts; the first one is <code>Stage</code>s.</p>
<p>On each frame, Bevy's scheduler goes through a predefined set of so-called <code>Stage</code>s, which are essentially group of operations performed on a schedule; they are the appropriate abstraction to use (for reasons we'll see in the following chapters) to model states.</p>
<p>By default, Bevy has several stages, however, we're interested only in one: the <code>Update</code> stage; the reason is that during the other stages, other operations are performed behind the scenes, and especially in a simple project, one doesn't want to touch them.</p>
<p>In order to accommodate the states we need, we can add new stages - the idea is that we schedule them to be run in the order we want, but always after <code>Update</code> and before the stage following it by default (called <code>PostUpdate</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="designing-the-states"><a class="header" href="#designing-the-states">Designing the states</a></h1>
<p>Now that we've examined all the concepts involved, let's design the Bevy's states.</p>
<p>We'll use the following code as reference, which is the source project as of this step:</p>
<pre><code class="language-rs">// source: mod.rs

pub fn build_input_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(player_input::player_input_system())
        .flush()
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
        .build()
}

pub fn build_player_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(collisions::collisions_system())
        .flush()
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
        .add_system(end_turn::end_turn_system())
        .build()
}

pub fn build_monster_scheduler() -&gt; Schedule {
    Schedule::builder()
        .add_system(random_move::random_move_system())
        .flush()
        .add_system(collisions::collisions_system())
        .flush()
        .add_system(map_render::map_render_system())
        .add_system(entity_render::entity_render_system())
        .add_system(end_turn::end_turn_system())
        .build()
}
</code></pre>
<h2 id="a-first-direct-translation"><a class="header" href="#a-first-direct-translation">A first, direct translation</a></h2>
<p>In a direct transation, we create one stage for each transaction:</p>
<table><thead><tr><th>stage description</th><th align="center">source scheduler number</th><th align="center">stage count</th></tr></thead><tbody>
<tr><td>get player input</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td>render player input</td><td align="center">1</td><td align="center">2</td></tr>
<tr><td>handle player collisions</td><td align="center">2</td><td align="center">3</td></tr>
<tr><td>render player collisions</td><td align="center">2</td><td align="center">4</td></tr>
<tr><td>move monsters</td><td align="center">3</td><td align="center">5</td></tr>
<tr><td>handle monster collisions</td><td align="center">3</td><td align="center">6</td></tr>
<tr><td>render move monsters</td><td align="center">3</td><td align="center">7</td></tr>
</tbody></table>
<p>All good! This can work, and it's a very straight model. Something important to keep in mind is that, in the game design, if the player doesn't press any key, the subsequent stages won't be executed!</p>
<h2 id="simplifying-the-source-project-states"><a class="header" href="#simplifying-the-source-project-states">Simplifying the source project states</a></h2>
<p>Now, let's look at the rendering systems: <code>map_render::map_render_system()</code> and <code>entity_render::entity_render_system()</code>; we notice two things:</p>
<ol>
<li>they are common to all the schedulers;</li>
<li>they need to be run in their separate transaction, otherwise, they may render a partial state (this would be the equivalent of the &quot;read uncommitted&quot; transaction level in database systems).</li>
</ol>
<p>However, if we consider that this all happens over a single frame, we now see an opportunity for simplification: we just need to render only once! Let's have a look at the new table:</p>
<table><thead><tr><th>stage description</th><th align="center">source scheduler number</th><th align="center">stage count</th></tr></thead><tbody>
<tr><td>get player input</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td>handle player collisions</td><td align="center">2</td><td align="center">2</td></tr>
<tr><td>move monsters</td><td align="center">3</td><td align="center">3</td></tr>
<tr><td>handle monster collisions</td><td align="center">3</td><td align="center">4</td></tr>
<tr><td>render</td><td align="center">4</td><td align="center">5</td></tr>
</tbody></table>
<p>We need a small modification here  If the player doesn't send any input, the rendering won't be executed. Fortunately, we can shift the render:</p>
<table><thead><tr><th>stage description</th><th align="center">source scheduler number</th><th align="center">stage count</th></tr></thead><tbody>
<tr><td>render</td><td align="center">4</td><td align="center">1</td></tr>
<tr><td>get player input</td><td align="center">1</td><td align="center">2</td></tr>
<tr><td>handle player collisions</td><td align="center">2</td><td align="center">3</td></tr>
<tr><td>move monsters</td><td align="center">3</td><td align="center">4</td></tr>
<tr><td>handle monster collisions</td><td align="center">3</td><td align="center">5</td></tr>
</tbody></table>
<p>Excellent. From the user perspective, if we render at the beginning of a frame, or at the end of the previous one, it makes no difference - except that, with the former approach, we've solved the rendering problem.</p>
<p>We can go further! we don't strictly need to sequentially render and get the player input in a sequence; this is a slow game, and rendering a tiny fraction of second after won't make any difference; the new plan is therefore:</p>
<table><thead><tr><th>stage description</th><th align="center">source scheduler number</th><th align="center">stage count</th></tr></thead><tbody>
<tr><td>render+get player input</td><td align="center">4+1</td><td align="center">1</td></tr>
<tr><td>handle player collisions</td><td align="center">2</td><td align="center">2</td></tr>
<tr><td>move monsters</td><td align="center">3</td><td align="center">3</td></tr>
<tr><td>handle monster collisions</td><td align="center">3</td><td align="center">4</td></tr>
</tbody></table>
<p>Notice that when we talk about a tiny fraction of second, it not <em>one frame</em> of delay; the input/rendering systems are rendered in parallel (as opposed to in a sequence), so there is virtually zero delay.</p>
<h2 id="summary-of-the-design"><a class="header" href="#summary-of-the-design">Summary of the design</a></h2>
<p>With the design above, we now have 4 stages:</p>
<ul>
<li>render+get player input</li>
<li>handle player collisions</li>
<li>move monsters</li>
<li>handle monster collisions</li>
</ul>
<p>We'll also keep the 3 game states of the source project:</p>
<ul>
<li>awaiting input</li>
<li>player turn</li>
<li>monster turn</li>
</ul>
<p>Remember: states are used to represent high-level game states, while stages are subdivisions of the states, for transactional purposes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-the-states-in-bevy"><a class="header" href="#implementing-the-states-in-bevy">Implementing the states in Bevy</a></h1>
<p>In this chapter, we'll use the <code>iyes_loopless</code> Bevy crate!</p>
<h2 id="adding-the-stages"><a class="header" href="#adding-the-stages">Adding the stages</a></h2>
<p>First, let's define the stages:</p>
<pre><code class="language-rs">// Port: game_stage.rs

#[derive(Debug, Clone, Eq, PartialEq, Hash, StageLabel)]
pub enum GameStage {
    MovePlayer,
    MoveMonsters,
    MonsterCollisions,
}
</code></pre>
<p>Is there one missing? No! For simplicity, we're going to use Bevy's standard one, <code>Update</code>, for the rendering and player input. It's perfectly possible to leave <code>Update</code> untouched, and add an extra state for those systems; it's up to the developer's taste.</p>
<p>Now, we'll need to register them; this is performed via some <code>App</code> APIs, of which, for simplicity, we'll use just one, <code>add_stage_after</code>:</p>
<pre><code class="language-rs">// Port: main.rs

ecs.add_stage_after(CoreStage::Update, MovePlayer, SystemStage::parallel())
    .add_stage_after(MovePlayer, MoveMonsters, SystemStage::parallel())
    .add_stage_after(MoveMonsters, MonsterCollisions, SystemStage::parallel());
</code></pre>
<p>Note that we're specifying that we want to run the systems of each stage in parallel (the alternative is <code>SystemStage::single_threaded()</code>), taking advantage of Bevy's ECS.</p>
<h2 id="adding-the-states"><a class="header" href="#adding-the-states">Adding the states</a></h2>
<p>Now, let's define the states:</p>
<pre><code class="language-rs">// Port: turn_state.rs

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum TurnState {
    AwaitingInput,
    PlayerTurn,
    MonsterTurn,
}
</code></pre>
<p>We don't need to register the states, but we need to tell the scheduler which is the starting one:</p>
<pre><code class="language-rs">// Port: main.rs

ecs.add_loopless_state(TurnState::AwaitingInput);
</code></pre>
<p>This is again, an API of <code>App</code> (but added by <code>iyes_loopless</code>).</p>
<h2 id="setting-the-systemsets"><a class="header" href="#setting-the-systemsets">Setting the <code>SystemSet</code>s</a></h2>
<p>Now we can add the <code>SystemSet</code>s.</p>
<pre><code class="language-rs">// Port: mod.rs (edited)

pub fn build_system_sets(app: &amp;mut App) {
    app.add_system_set(
        SystemSet::new()
            .with_system(map_render::map_render)
            .with_system(entity_render::entity_render),
    );

    app.add_system(
        player_input::player_input
            .run_in_state(AwaitingInput)
    );

    app.add_system_set_to_stage(
        GameStage::MovePlayer,
        ConditionSet::new()
            .run_in_state(TurnState::PlayerTurn)
            .with_system(collisions::collisions)
            .with_system(end_turn::end_turn)
            .into(),
    );

    app.add_system_set_to_stage(
        GameStage::MoveMonsters,
        ConditionSet::new()
            .run_in_state(TurnState::MonsterTurn)
            .with_system(random_move::random_move)
            .into(),
    );

    app.add_system_set_to_stage(
        GameStage::MonsterCollisions,
        ConditionSet::new()
            .run_in_state(TurnState::MonsterTurn)
            .with_system(collisions::collisions)
            .with_system(end_turn::end_turn)
            .into(),
    );
}
</code></pre>
<p>The state handling is done; let's review it.</p>
<p>First, rendering:</p>
<pre><code class="language-rs">    app.add_system_set(
        SystemSet::new()
            .with_system(map_render::map_render)
            .with_system(entity_render::entity_render),
    );
</code></pre>
<p>By not specifying the stage, we're adding those systems to the <code>Update</code> stage. We're also not specifying a state, as we don't strictly need it; we could bind it to the <code>AwaitingInput</code> state, but conceptually speaking, there isn't such connection.</p>
<p>Note how there is no temporal dependency between the two rendering systems (therefore, they will run in parallel); since they can execute independently (they draw to two different planes), we take the chance to parallelize them.</p>
<p>Now, the player input:</p>
<pre><code class="language-rs">    app.add_system(
        player_input::player_input
            .run_in_state(AwaitingInput)
    );
</code></pre>
<p>This also goes in <code>Update</code>, however, we slot it in the associated game state (<code>AwaitingInput</code>).</p>
<p>Now, the player move:</p>
<pre><code class="language-rs">    app.add_system_set_to_stage(
        GameStage::MovePlayer,
        ConditionSet::new()
            .run_in_state(TurnState::PlayerTurn)
            .with_system(collisions::collisions)
            .with_system(end_turn::end_turn)
            .into(),
    );
</code></pre>
<p>There are a few notable things here. First, we need to invoke <code>ConditionSet#into()</code> - this is because such type belongs to the <code>iyes_loopless</code> crate, and it needs to be converted to make it compatible with Bevy's <code>add_system_set_to_stage</code> APIs.</p>
<p>Then, we're now adding the system set to a stage (<code>MovePlayer</code>).</p>
<p>Like for rendering, we run the systems in parallel. Since we are sure that Bevy will wait for both systems to complete before moving to the next stage (<code>MoveMonsters</code>), there's no risk of a race condition.</p>
<p>The rest of the systems follow the same structure.</p>
<p>A small detail not to forget is turn state change is performed by the state machine system <code>end_turn</code>, but not in the <code>AwaitingInput</code> state - in this case, it's performed by the <code>player_input</code> system (since it depends on the user input).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-step-0703"><a class="header" href="#introduction-to-step-0703">Introduction to step 07.03</a></h1>
<p>In this concept we're going to explore event passing.</p>
<p>The directory name is <code>07_TurnBasedGames_03_intent</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managed-event-passing"><a class="header" href="#managed-event-passing">Managed event passing</a></h1>
<p>This chapter presents an interesting departure from the source project! We're going to implement event passing; this is interesting because it's possible to observe the improvements offered compared to manual event handling (which is the implementation chosen in the source project).</p>
<h2 id="a-look-at-a-manual-implementation"><a class="header" href="#a-look-at-a-manual-implementation">A look at a manual implementation</a></h2>
<p>Let's see what the source project implementation. Since the messages are regular entities, first, they need to be declared:</p>
<pre><code class="language-rs">// Source: component.rs

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct WantsToMove {
    pub entity: Entity,
    pub destination: Point,
}
</code></pre>
<p>Now, they're simply added to the world:</p>
<pre><code class="language-rs">// Source: player_input.rs (edited)

pub fn player_input(
    commands: &amp;mut CommandBuffer,
) {
    // ...

    // Legions push function doesnt work with single-component insertions

    commands.push((
        (),
        WantsToMove {
            entity: *player_entity,
            destination: player_destination,
        },
    ));

    // ...
}
</code></pre>
<p>Here we observe a small limitation of Legion, in particular, when used for events - it doesn't accept insertion of individual components, so we need to add a phony one (the empty tuple <code>()</code>).</p>
<p>Reading is performed via a standard query:</p>
<pre><code class="language-rs">// Source: movement.rs (extract)

pub fn movement(
    entity: &amp;Entity,
    want_move: &amp;WantsToMove,
    // ...
    commands: &amp;mut CommandBuffer,
) {
    if map.can_enter_tile(want_move.destination) {
        // ... operate on `want_move`
    }

    commands.remove(*entity);
}
</code></pre>
<p>Note how we have to manually remove the pseudo-message entity.</p>
<p>That's all. This implementation is very simple, which works well in the design of this game.</p>
<h2 id="bevys-event-passing"><a class="header" href="#bevys-event-passing">Bevy's Event passing</a></h2>
<p>Bevy's managed event passing is equally simple. We define the event type, and we register it:</p>
<pre><code class="language-rs">// Port: events.rs

pub struct WantsToMove {
    pub entity: Entity,
    pub destination: Point,
}

// Port: main.rs

ecs.add_event::&lt;WantsToMove&gt;();
</code></pre>
<p>Note that differently from entities, message types don't need to be derived as components; in the port, this gives a minor simplification - we don't need to use the wrapper component <code>PointC</code> - we use just <code>Point</code>.</p>
<p>Now, let's send the events:</p>
<pre><code class="language-rs">// Port: player_input.rs (edit)

pub fn player_input(
    mut move_events: EventWriter&lt;WantsToMove&gt;,
) {
    // ... compute the player destination ...

    move_events.send(WantsToMove {
        entity: *player_entity,
        destination: player_destination,
    });

    // ...
}
</code></pre>
<p>and read them:</p>
<pre><code class="language-rs">// Port: movement.rs (edit)

pub fn movement(
    mut move_events: EventReader&lt;WantsToMove&gt;,
    // ...
) {
    for &amp;WantsToMove {
        entity,
        destination,
    } in move_events.iter()
    {
        if map.can_enter_tile(destination) {
            // ... operate on entity/destination
        }
    }
}
</code></pre>
<p>Very straightforward. There is a very important difference of the port: we don't need to remove the message; this is taken care of by Bevy.</p>
<h2 id="systems-ordering"><a class="header" href="#systems-ordering">Systems ordering</a></h2>
<p>There are two crucial concepts to be aware of, when using Bevy's events:</p>
<ol>
<li>events persist for at most two frames - the frame where the event is sent, and the next;</li>
<li>the developer must take care of the systems ordering, in order to read the events as soon as possible.</li>
</ol>
<p>In some games, lag is not a problem, however, in some others, if the systems ordering is improperly designed, event reading may be lag, and the lag can propagate to other systems/frames.</p>
<p>It's therefore useful to review how system ordering is designed in the port, at this stage:</p>
<pre><code class="language-rs">// Port: mod.rs (extract)

// Here we write the event; this is the default (Update) stage.
//
app.add_system(
    player_input::player_input.run_in_state(AwaitingInput)
);

// Here we read the events; the stage is the next, which guarantees the ordering.
//
app.add_system_set_to_stage(
    MovePlayer,
    ConditionSet::new()
        .run_in_state(PlayerTurn)
        .with_system(movement::movement) // reads the event
        .into(),
);
</code></pre>
<p>We don't need to introduce any syncing (ie. extra stages) - the project's states and actions are well-defined, so the sync points (implemented via stages) fit cleanly and, in this case, for free.</p>
<h2 id="considerations"><a class="header" href="#considerations">Considerations</a></h2>
<p>Whether to use or not managed event passing, is a valid question; after all, one can just write entities, send them around, then remove them. In the context of this project, the advantages that managed events passing gives are:</p>
<ul>
<li>it avoids manual removal of the messages;</li>
<li>the implementation is semantically more consistent with its intent;</li>
<li>as a consequence of the previous point, workarounds are not necessary.</li>
</ul>
<p>These don't constitute a very significant improvement, however, given the simplicity of Bevy's API, in my opinion, using it is a no-brainer.</p>
<p>One larger projects, when there are multiple readers, the advantage of not having to manually clear the events, is definitely more significant.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
